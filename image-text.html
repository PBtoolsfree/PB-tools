<script>
        // Get Elements
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const imagePreview = document.getElementById('imagePreview');
        const noImagePlaceholder = document.getElementById('noImagePlaceholder');
        const convertBtn = document.getElementById('convertBtn');
        const outputText = document.getElementById('outputText');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const statusText = document.getElementById('statusText');
        const copyBtn = document.getElementById('copyBtn');

        let selectedFile = null;

        // --- Event Listeners for File Handling ---
        fileInput.addEventListener('change', (e) => handleFileSelect(e.target.files[0]));

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('dragover');
            });
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('dragover');
            });
        });

        dropZone.addEventListener('drop', (e) => {
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileSelect(files[0]);
                fileInput.files = files; 
            }
        });

        function handleFileSelect(file) {
            if (!file || !file.type.startsWith('image/')) {
                alert('Please select a valid image file.');
                return;
            }
            selectedFile = file;
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
                imagePreview.style.display = 'block';
                noImagePlaceholder.style.display = 'none';
                convertBtn.disabled = false;
                outputText.value = '';
                copyBtn.style.display = 'none';
                resetProgress();
            }
            reader.readAsDataURL(file);
        }

        // --- NEW: Image Pre-processing Function ---
        // This cleans the image (Grayscale + Contrast) to help the AI read it better
        function preprocessImage(imgElement) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match image
            canvas.width = imgElement.naturalWidth;
            canvas.height = imgElement.naturalHeight;
            
            // Draw original image
            ctx.drawImage(imgElement, 0, 0);
            
            // Get raw pixel data
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            
            // Loop through every pixel to convert to Black & White
            // We use a threshold to separate text (usually light) from background
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Calculate brightness (Luma)
                const gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                
                // Thresholding: If pixel is bright (text), make it BLACK. If dark (bg), make it WHITE.
                // Note: Tesseract prefers Black text on White background.
                // Adjust '100' if needed (0-255). Lower grabs more detail, Higher removes more noise.
                const threshold = 110; 
                
                // Since your image has Light Text on Dark BG, we INVERT the logic:
                // If brightness > threshold (It's the text) -> Set to Black (0)
                // If brightness < threshold (It's the bg)   -> Set to White (255)
                const val = (gray > threshold) ? 0 : 255;

                data[i] = val;     // R
                data[i+1] = val;   // G
                data[i+2] = val;   // B
            }
            
            ctx.putImageData(imgData, 0, 0);
            
            // Return the processed image data URL
            return canvas.toDataURL('image/jpeg');
        }

        // --- OCR Conversion Logic ---
        convertBtn.addEventListener('click', async () => {
            if (!selectedFile) return;

            convertBtn.disabled = true;
            convertBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
            progressContainer.style.display = 'block';
            outputText.value = 'Optimizing image and extracting text...';
            copyBtn.style.display = 'none';
            
            try {
                 // 1. Preprocess the image (Clean it up)
                 statusText.innerText = "Preprocessing image...";
                 const processedImage = preprocessImage(imagePreview);

                 // 2. Initialize Worker
                 const worker = await Tesseract.createWorker({
                    logger: m => updateProgress(m)
                 });
                 
                 await worker.loadLanguage('eng');
                 await worker.initialize('eng');
                 
                 // 3. Recognize text from the PROCESSED image
                 statusText.innerText = "Recognizing text...";
                 const { data: { text } } = await worker.recognize(processedImage);
                 
                 if(text.trim().length === 0) {
                      outputText.value = "No readable text found. The image might be too blurry or stylized.";
                 } else {
                      outputText.value = text;
                      copyBtn.style.display = 'flex';
                 }
                 
                 await worker.terminate();

            } catch (err) {
                console.error(err);
                outputText.value = "Error: " + err.message;
                statusText.innerText = "Failed.";
                statusText.style.color = "red";
            } finally {
                convertBtn.disabled = false;
                convertBtn.innerHTML = '<i class="fas fa-cog"></i> Extract Text Again';
                setTimeout(() => {
                     if(statusText.innerText === "Completed!") {
                         progressContainer.style.display = 'none';
                     }
                }, 3000);
            }
        });

        function updateProgress(packet) {
             if(packet.status === 'recognizing text') {
                const percent = Math.round(packet.progress * 100);
                progressFill.style.width = `${percent}%`;
                statusText.innerText = `Reading... ${percent}%`;
             } else {
                 statusText.innerText = formatStatus(packet.status);
             }
             
             if(packet.status === "done" || (packet.status === 'recognizing text' && packet.progress === 1)) {
                 statusText.innerText = "Completed!";
                 progressFill.style.width = "100%";
             }
        }

        function formatStatus(status) {
            return status.charAt(0).toUpperCase() + status.slice(1) + "...";
        }

        function resetProgress() {
            progressContainer.style.display = 'none';
            progressFill.style.width = '0%';
            statusText.innerText = 'Initializing...';
            statusText.style.color = 'var(--text-gray)';
        }

        copyBtn.addEventListener('click', () => {
            outputText.select();
            outputText.setSelectionRange(0, 99999);
            navigator.clipboard.writeText(outputText.value).then(() => {
                const originalText = copyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                setTimeout(() => {
                    copyBtn.innerHTML = originalText;
                }, 2000);
            });
        });
    </script>
